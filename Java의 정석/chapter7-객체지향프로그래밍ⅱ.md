## 1. 상속

### 1.1 상속의 정의와 장점

- 상속이란?
  - 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것
- 코드의 재사용성을 높이고 코드의 중복을 제거 -> 프로그램의 생산성과 유지보수에 크게 기여
- 조상 클래스
  - 상속해주는 클래스
  - 부모 클래스, 상위 클래스, 기반 클래스
- 자손 클래스
  - 상속 받는 클래스
  - 자식 클래스, 하위 클래스, 파생된 클래스
- 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.
- 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.

### 1.2 클래스간의 관계 - 포함관계

### 1.3 클래스간의 관계 결정하기

- '~은 ~이다(is-a)' -> 상속관계
- '~은 ~을 가지고 있다(has-a)' -> 포함관계

### 1.4 단일 상속

### 1.5 Object클래스 - 모든 클래스의 조상

- Object클래스는 모든 클래스 상속계층도의 최상위에 있는 조상클래스이다.

## 2. 오버라이딩(overriding)

### 2.1 오버라이딩이란?

- 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것

### 2.2 오버라이딩의 조건

- 이름이 같아야 한다.
- 매개변수가 같아야 한다.
- 반환타입이 같아야 한다.
- 1. 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경 할 수 없다.
- 2. 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.
  - 예외의 개수각 아닌 조건이 중요
- 3. 인스턴스메서드를 static메서드로 또는 그 반대로 변경할 수 없다.

### 2.3 오버로딩 vs. 오버라이딩

- 오버로딩 : 기존에 없는 새로운 메서드를 정의하는 것
- 오버라이딩 : 상속받은 메서드의 내용을 변경하는 것

### 2.4 super

- 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수
- 상속받은 멤버와 자신의 멤버와 이름이 같을 때 super를 붙여 구별

### 2.5 super() - 조상 클래스의 생성자

- 조상 클래스의 생성자를 호출하는데 사용
- Object클래스를 제외한 모든 클래스의 생성자 첫 줄에 생성자.this() 또는 super(), 를 호출해야한다.
- 컴파일러가 자동적으로 'super()'를 생성자의 첫줄에 삽입한다.

## 3. package와 import

### 3.1 패키지(package)

- 클래스의 묶음
- 클래스 또는 인터페이스를 포함시킬 수 있다.
- 서로 관련된 클래스들끼리 그룹 단위로 묶어 놓음으로써 클래스를 효율적으로 관리할 수 있다.
- 클래스가 물리적으로 하나의 클래스파일인 것과 같이 패키지는 물리적으로 하나의 디렉토리이다.

## 4. 제어자(modifier)

### 4.1 제어자란?

- 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여
- 접근 제어자 : public, protected, default, private
- 그 외 : static, final, abstract, native, transient, synchronized, volatile, strictfp
- 접근 제어자는 한 번에 하나만 선택

### 4.2 static - 클래스의, 공통적인

### 4.3 final - 마지막의, 변경될 수 없는

### 4.4 abstract - 추상의, 미완성의

### 4.5 접근 제어자(access modifier)

- 멤버 또는 클래스에 사용되며, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다.
  - private : 같은 클래스 내에서만 접근이 가능하다.
  - default : 같은 패키지 내에서만 접근이 가능하다.
  - protected : 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다.
  - public : 접근 제한이 전혀 없다.  
    ![Alt text](image.png)

### 4.6 제어자의 조합

-주의사항

- 1. 메서드에 static과 abstract를 함께 사용할 수 없다.
- 2. 클래스에 abstract와 final을 동시에 사용할 수 없다.
- 3. abstract메서드의 접근 제어자가 private일 수 없다.
- 4. 메서드에 private와 final을 같이 사용할 필요가 없다.

## 5. 다형성

### 5.1 다형성이란?

- 여러 가지 형태를 가질 수 있는 능력
- 조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 하는 것
- 조상 클래스 타비의 참조변수로 자손 클래스의 인스턴스를 참조하도록 하는 것이 가능하다.
<pre>
조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.
반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수는 없다.</pre>

### 5.2 참조변수의 형변환

<pre>
자손타입 -> 조상타입(Up-casting) : 형변환 생략가능
조상타입 -> 자손타입(Down-casting) : 형변환 생략불가
</pre>

- 업캐스팅을 할시에는 실제 인스턴스가 갖고 있는 멤버의 개수보다 적을 것이 분명하기에 생략할 수 있다.
- 다운캐스팅시에는 멤버의 개수가 더 많아지므로 생략을 할 수 없다.
- instanceof연산자를 사용하여 참조변수가 참조하고 있는 실제 인스턴스의 타입을 확인할 수 있다.
- 형변환은 참조변수의 타입을 변환하는 것이지 인스턴스를 변환하는 것은 아니기 때문에 참조변수의 형변환은 인스턴스에 아무런 영향을 미치지 않는다.
- 단지 참조변수의 형변환을 통해서, 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위(개수)를 조절하는 것뿐이다.
- 서로 상속관계에 있는 타입간의 형변환은 양방향으로 자유롭게 수행될 수 있으나, 참조변수가 가리키는 인스턴스의 자손타입으로 형변환은 허용되지 않는다.
- 그래서 참조변수가 가리키는 인스턴스의 타입이 무엇인지 확인하는 것이 중요하다.

### 5.3 instanceof연산자

- 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용한다.
- 왼쪽에는 참조변수, 오른쪽에는 타입(클래스명)이 위치
- 결과로 boolean값인 true 또는 false중에 하나를 반환
- 어떤 타입에 대한 instanceof연산의 결과가 true라는 것은 검사한 타입으로 형변환이 가능하다는 것을 뜻한다.

### 5.4 참조변수와 인스턴스의 연결

- 메서드의 경우 조상 클래스의 메서드를 자손의 클래스에서 오버라이딩한 경우에도 참조변수의 타입에 관계없이 항상 실제 인스턴스의 메서드(오버라이딩된 메서드)가 호출된다.
- 멤버변수의 경우 참조변수의 타입에 따라 달라진다.

### 5.5 매개변수의 다형성

- 참조변수의 다형적인 특징은 메서드의 매개변수에도 적용된다.

### 5.6 여러 종류의 객체를 배열로 다루기

## 6. 추상클래스(abstract class)

### 6.1 추상클래스란?

- 미완성된 클래스
- 상속을 통해서 자손클래스에 의해서만 완성될 수 있다.

### 6.2 추상메서드(abstract method)

- 조상 클래스에서는 선언부만을 작성하고, 주석을 덧붙여 어떤 기능을 수행할 목적으로 작성되었는지 알려 주고, 실제 내용은 비워두는 것이다.
<pre>
/* 주석을 통해 어떤 기능을 수행할 목적으로 작성하였는지 설명한다. */
abstract 리턴타입 메서드이름();
</pre>
- 추상클래스로부터 상속받는 자속클래스는 오버라이딩을 통해 조상인 추상클래스의 추상메서드를 모두 구현해야한다.

### 6.3 추상클래스의 작성

- 추상화 : 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업
- 구체화 : 상속을 통해 클래스를 구현, 확장하는 작업

## 7. 인터페이스(interface)

### 7.1 인터페이스란?

- 일종의 추상클래스
- 추상클래스처럼 추상메서드를 갖미나 추상클래스보다 추상화 정도가 높아서 추상클래스와 달리 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다.
- 오직 추상메서드와 상수만을 멤버로 갖을 수 있다.

### 7.2 인터페이스의 작성

- 키워드로 class 대신 interface를 사용
- 접근제어자로 public 또는 default 사용

```java
interface 인터페이스이름
  public static final 타입 상수이름 = 값;
  public abstract 메서드이름(매개변수목록)
```

- 제약사항
  - 모든 멤버변수는 public static final 이어야 하며, 이를 생략할 수 있다.
  - 모든 메서드는 public abstract 이어야 하며, 이를 생략할 수 있다.(단, static메서드와 디폴트 메서드는 예외(JDK1.8부터))

### 7.3 인터페이스의 상속

- 인터페이스는 인터페이스로부터만 상속받을 수 있으며, 클래스와는 달리 다중상속이 가능하다.
- 인터페이스는 클래스와 달리 Object클래스와 같은 최고 조상이 없다.

### 7.4 인터페이스의 구현

- 추상클래스처럼 그 자체로는 인스턴스를 생성 할 수 없다.
- extends 대신에 implements를 사용하여 상속한다.

```java
class 클래스이름 implements 인터페이스이름{
  // 인터페이스에 정의된 추상메서드를 구현해야 한다.
}
```

- 구현하는 인터페이스의 메서드 중 일부만 구현한다면, abstract를 붙여서 추상클래스로 선언해야 한다.
- 상속과 구현을 동시에 할 수 있다.

### 7.5 인터페이스를 이용한 다중상속

### 7.6 인터페이스를 이용한 다형성

- **_리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반화한다는 것을 의미한다._**

### 7.7 인터페이스의 장점

- 개발 시간을 단축 시킬 수 있다.
- 표준화가 가능하다.
  - 프로젝트에 사용되는 기본 틀을 인터페이스로 작성한 다음, 개발자들에게 인터페이스를 구현하여 프로그램을 작성하도록 함으로써 보다 일관되고 정형화된 프로그램의 개발이 가능하다.
- 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.
  - 서로 상속관계에 있지 않고, 같은 조상클래스를 가지고 있지 않은 서로 아무런 관계도 없는 클래스들에게 하나의 인터페이스를 공통적으로 구현함으로써 관계를 맺어 줄 수 있다.
- 독립적인 프로그래밍이 가능하다.
  - 인터페이스를 이용하면 클래스의 선언과 구현을 분리시킬 수 있기 때문에 실제구현에 독립적인 프로그램을 작성하는 것이 가능하다.

### 7.8 인터페이스의 이해

- 클래스를 사용하는 쪽(User)과 클래스를 제공하는 쪽(Provider)이 있다.
- 메서드를 사용(호출)하는 쪽(User)에서는 사용하려는 메서드(Provider)의 선언부만 알면 된다.(내용은 몰라도 된다.)

### 7.9 디폴트 메서드와 static 메서드

- 인터페이스의 모든 메서드는 추상 메서드이어야 한다.
- 인터페이스와 관련된 static 메서드는 별도의 클래스에 따로 두어야 한다.
- 인터페이스의 static메서드 역시 접근 제어자가 항상 public이며, 생략할 수 있다.

#### 디폴트 메서드

- 추상 메서드의 기본적인 구현을 제공하는 메서드
- 추상 메서드가 아니기 때문에 디폴트 메서드가 새로 추가되어도 해당 인터페이스를 구현한 클래스를 변경하지 않아도 된다.
- 키워드 default를 붙이며, 추상 메서드와 달리 일반 메서드처럼 몸통{}이 있어야 한다.
- 디폴트 메서드 역시 접근 제어자가 public이며, 생략가능하다.

- 새로 추가된 디폴트 메서드가 기존의 메서드와 이름이 중복되어 충돌하는 경우 해결 규칙
  - 1. 여러 인터페이스의 디폴트 메서드 간의 충돌
    - 인터페이스를 구현한 클래스에서 디폴트 메서드를 오버라이딩해야 한다.
  - 2. 디폴트 메서드와 조상 클래스의 메서드 간의 충돌
    - 조상 클래스의 메서드가 상속되고, 디폴트 메서드는 무시된다.
- 필요한 쪽의 메서드와 같은 내용으로 오버라이딩 해도 된다.

## 8. 내부 클래스(inner class)

### 8.1 내부 클래스란?

- 내부 클래스는 클래스 내에 선언된 클래스
- 내부 클래스의 장점
  - 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다.
  - 코드의 복잡성을 줄일 수 있다(캡슐화).

```java
class A { // 외부 클래스
  class B{ // 내부 클래스
  }
}
```

- 이때 내부 클래스B는 외부 클래스인 A를 제외하고는 다른 클래스에서 잘 사용되지 않는 것이어야 한다.

### 8.2 내부 클래스의 종류와 특징

|   내부 클래스   |                                                                                특 징                                                                                |
| :-------------: | :-----------------------------------------------------------------------------------------------------------------------------------------------------------------: |
| 인스턴스 클래스 | 외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 인스턴스멤버처럼 다루어진다. 주로 외부 클래스의 인스턴스멤버들과 관련된 작업에 사용될 목적으로 선언된다.  |
|  스태틱 클래스  | 외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 static멤버처럼 다루어진다. 주로 외부 클래스의 static멤버, 특히 static메서드에서 사용될 목적으로 선언된다. |
|   지역 클래스   |                                       외부 클래스의 메서드나 초기화블럭 안에 선언하며, 선언된 영역 내부에서만 사용될 수 있다.                                       |
|   익명 클래스   |                                                  클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스(일회용)                                                  |

### 8.3 내부 클래스의 선언

### 8.4 내부 클래스의 제어자와 접근성

- 내부 클래스도 클래스이기 때문에 abstract나 final과 같은 제어자를 사용할 수 있다.
- 또한, 멤버변수들처럼 private, protected과 접근제어라도 사용이 가능하다.

### 8.5 익명 클래스
