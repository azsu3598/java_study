## 1. 객체지향언어

### 1.2 객체지향언어

- 주요 특징
  - 1. 코드의 재사용성이 높다.
    - 새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있다.
  - 2. 코드의 관리가 용이하다.
    - 코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있다.
  - 3. 신뢰성이 높은 프로그래밍을 가능하게 한다.
    - 제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며, 코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다.

## 2. 클래스와 객체

### 2.1 클래스와 객체의 정의와 용도

- 클래스 : '객체를 정의해놓은 것' 또는 '객체의 설계도 또는 틀'
- 클래스는 객체를 생성하는데 사용되며, 객체는 클래스에 정의된 대로 생성된다.  
  <code>
  클래스의 정의 : 객체를 정의해 놓은 것이다.  
  클래스의 용도 : 객체를 생성하는데 사용된다.  
  객체의 정의 : 실제로 존재하는 것, 사물 또는 개념  
  객체의 용도 : 객체가 가지고 있는 기능과 속성에 따라 다름  
  </code>

### 2.2 객체와 인스턴스

- 인스턴스화(instantiate) : 클래스로부터 객체를 만드는 과정
- 인스턴스(instance) : 클래스로부터 만들어진 객체

### 2.3 객체의 구성요소 - 속성과 기능

- 속성 : 멤버변수, 특성, 필드, 상태
- 기능 : 메서드, 함수, 행위

### 2.4 인스턴스의 생성과 사용

<pre>
클래스명 변수명; // 클래스의 객체를 참조하기 위한 참조변수를 선언    
변수명 = new 클래스명(); // 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장  
TV t; // TV클래스 타입의 참조변수 t선언  
t = new TV(); // TV인스턴스를 생성한 후, 생서된 TV인스턴스의 주소를 t에 저장  
</pre>

### 2.5 객체 배열

- 객체를 배열로 다루는 것
- 객체 배열 안에 객체가 저장되는 것이 아닌, 객체의 주소가 저장된다.

```java
Tv[] tvArr = new Tv[3]; // 길이가 3인 Tv타입의 참조변수 배열
// 객체를 생성해서 배열의 각 요소에 저장
tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv();
// 배열의 초기화 블록 사용
Tv[] tvArr[3] = {new Tv(), new Tv(), new Tv()};
```

### 2.6 클래스의 또 다른 정의

1. 클래스 - 데이터와 함수의 결합
<pre>
1. 변수 : 하나의 데이터를 저장할 수 있는 공간
1. 배열 : 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
1. 구조체 : 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
1. 클래스 : 데이터와 함수의 결합(구조체+함수)
</pre>
1. 클래스 - 사용자정의 타입(user-defined type)

- 프로그래밍언어에서 제공하는 자료형 외에 프로그래머가 서로 관련된 변수들을 묶어서 하나의 타입으로 새로 추가하는 것

## 3. 변수와 메서드

### 3.1 선언위치에 따른 변수의 종류

1. 인스턴스변수(instance variable)

- 클래스 영역에 선언되며, 클래스의 인스턴스를 생성할 때 만들어진다.
- 독립적인 저장공간을 가지므로 서로 다른 값을 가질 수 있다.
- 인스턴스마다 고유한 상태를 유지해야하는 속성의 경우, 인스턴스변수로 선언한다.

2. 클래스변수(class variable)

- 인스턴스변수 앞에 static을 붙여서 선언
- 모든 인스턴스가 공통된 저장공간(변수)을 공유
- 인스턴스를 생성하지 않고도 언제라도 바로 사용할 수 있다. -> '클래스이름.클래스변수'
- 클래스가 메모리에 '로딩'될 때 생성되어 프로그램이 종료될 때 까지 유지, public을 앞에 붙이면 '전역변수'의 성격을 갖는다.

3. 지역변수(local variable)

- 메서드 내에 선언되어 메서드 내에서만 사용 가능하며, 메서드가 종료되면 소멸

### 3.2 클래스변수와 인스턴스변수

- 인스턴스변수는 인스턴스가 생성될 때 마다 생성되므로 인스턴스마다 각기 다른 값을 유지할 수 있지만, 클래스 변수는 모든 인스턴스가 하나의 저장공간을 공유하므로, 항상 공통된 값을 갖는다.

### 3.3 메서드

- 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것
- 내부가 보이지 않는 '블랙박스'라고도 한다.

#### 메서드를 사용하는 이유

1. 높은 재사용성(reusability)

- 한번 만들어 놓은 메서드는 몇 번이고 호출할 수 있으며, 다른 프로그램에서도 사용이 가능하다.

2. 중복된 코드의 제거

- 반복적으로 나타나는 문장들을 메서드로 만들어서 사용하면 코드의 중복이 제거되고, 변경사항이 발생했을 때 메서드만 수정하면 되므로 관리가 쉽고 오류의 발생가능성이 낮아진다.

3. 프로그램의 구조화

### 3.4 메서드의 선언과 구현

- 메서드는 '선언부(header, 머리)'와 '구현부(body, 몸통)'로 이루어져 있다.

```java
int add(int a, int b) // 선언부
{
  int result = a +b;
  return result; // 호출한 메서드로 결과를 반환
} // 구현부
```

#### 메서드 선언부(method declaration, method header)

- '메서드의 이름', '매개변수 선언', '반환타입'으로 구성
- 두 변수의 타입이 같아도 변수의 타입을 생략할 수 없다.

```java
int add(int x, y) {...} // 에러. 매개변수 y의 타입이 없다.
```

#### 지역변수(local variable)

- 메서드 내에 선언된 변수
- 서로 다른 메서드라면 같은 이름의 변수를 선언 할 수 있다.

### 3.5 메서드의 호출

#### 인자와 매개변수

- 인자 또는 인수 : 메서드를 호출할 때 괄호() 안에 지정해준 값들
- 인자의 개수와 순서는 호출된 메서드에 선언된 매개변수와 일치해야 한다.
- 인자의 타입은 매개변수의 타입과 일치하거나 자동 형변환이 가능한 것이어야 한다.

### 3.6 return문

- 현재 실행중인 메서드를 종료하고 호출한 메서드로 되돌아간다.
- 반환타입이 void인 경우, 컴파일러가 메서드의 마지막에 'return;'을 자동적으로 추가해준다.
- 반환값이 있는 경우, 반드시 return문이 있어야한다.

#### 반환값

#### 매개변수의 유효성 검사

### 3.7 JVM의 메모리 구조

1. 메서드 영역(method area)

- 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일(\*.class)을 읽어서 분석하여 클래스에
  대한 정보(클래스 데이터)를 이곳에 저장한다.
- 이 때, 그 클래스의 클래스변수(class variable)도 이 영역에 함께 생성된다.

2. 힙(heap)

- 인스턴스가 생성되는 공간
- 인스턴스변수들이 생성되는 공간

3. 호출스택(call stack 또는 execution stack)

- 메서드의 작업에 필요한 메모리 공간을 제공
- 메서드가 작업을 마치면 할당되었던 메모리공간은 반환되워 비워진다.
  특징
- 메서드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당받는다.
- 메서드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거된다.
- 호출스택의 제일 위에 있는 메서드가 현재 실행 중인 메서드이다.
- 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.

### 3.8 기본형 매개변수와 참조형 매개변수

- 기본형 매개변수 : 변수의 값을 읽기만 할 수 있다.(read only)
- 참조형 매개변수 : 변수의 값을 읽고 변경할 수 있다.(read & write)

### 3.9 참조형 반환타입

### 3.10 재귀호출(recursive call)

- 메서드의 내부에서 메서드 자신을 다시 호출하는 것
- 재귀 메서드 : 재귀호출을하는 메서드

### 3.11 클래스 메서드와 인스턴스 메서드

- 인스턴스 메서드는 인스턴스 변수와 관련된 작업을 하는, 즉 메서드의 작업을 수행하는데 인스턴스 변수를 필요로 하는 메서드
- 인스턴스 메서드 역시 인스턴스를 생성해야만 호출할 수 있다.
- 인스턴스와 관계없는 메서드를 클래스 메서드로 정의한다.
- 1. 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다.
- 2. 클래스 변수는 인스턴스를 생성하지 않아도 사용할 수 있다.
- 3. 클래스 메서드는 인스턴스 변수를 사용할 수 없다.
- 4. 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.

### 3.12 클래스 멤버와 인스턴스 멤버간의 참조와 호출

- 클래스멤버가 인스턴스 멤버를 참조 또는 호출하고자 하는 경우에는 인스턴스를 생성해야한다.
- 인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만, 클래스멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수 있다.
- 인스턴스 멤버간의 호출에는 문제가 없다.

## 4. 오버로딩(overloading)

### 4.1 오버로딩이란?

- 한 클래스 내에 같은 이름의 메서도를 여러 개 정의하는 것

### 4.2 오버로딩의 조건

- 1. 메서드 이름이 같아야 한다.
- 2. 매개변수의 개수 또는 타입이 달라야 한다.
- 반환타입은 오버로딩을 구현하는데 아무런 영향을 주지 못한다

### 4.3 오버로딩의 예

### 4.4 오버로딩의 장점

### 4.5 가변인자와 오버로딩

- 메서드의 매개변수 개수를 동적으로 지정하는 것
- 가변인자 외에도 매개변수가 더 있다면, 가변인자를 매개변수 중에서 가장 마지막에 선언해야한다.

```java
public PrintStream printf(String format, Object... args) {...}
```

```java
String concatenate(String s1, String s2) {...}
String concatenate(String s1, String s2, String s3) {...}
String concatenate(String s1, String s2, String s3, String s4) {...}
-> String concatenate(String... str) {...}
```

- 주의사항
  - 가변인자를 선업한 메서드를 오버로딩하면, 메서드를 호출했을 때 구별되지 못하는 경우가 발생하기 쉽다.
  - 가능하면 가변인자를 사용한 메서드를 오버로딩하지 않는 것이 좋다.

## 5. 생성자

### 5.1 생성자란?

- 인스턴스 초기화 메서드
- 조건
  - 1. 생성자의 이름은 클래스의 이름과 같아야 한다.
  - 2. 생성자는 리턴 값이 없다.

### 5.2 기본 생성자(default constructor)

- 클래스 이름(){}
- 기본 생성자가 컴파일러에 의해서 추가되는 경우는 클래스에 정의된 생성자가 하나도 없을 때 뿐이다.

### 5.3 매개변수가 있는 생성자

### 5.4 생성자에서 다른 생성자 호출하기 - this(), this

- 생성자 간에도 서로 호출이 가능하다
- 조건

  - 1. 생성자의 이름으로 클래스 이름 대신 this를 사용한다.
  - 2. 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.

- this
  - 인스턴스 자신을 가리키는 **참조변수**, 인스턴스의 주소가 저장되어 있다.
  - 모든 인스턴스메서드에 지역변수로 숨겨진 채로 존재한다.
- this(), this(매개변수)
  - 생성자, 같은 클래스의 다른 **생성자**를 호출할 때 사용한다.

### 5.5 생성자를 이용한 인스턴스의 복사

## 6. 변수의 초기화

### 6.1 변수의 초기화

- 변수를 선언하고 처음으로 값을 저장하는 것
- 가능하면 선언과 동시에 적절한 값으로 초기화 하는것이 바람직하다.
- 지역변수는 사용하기 전에 반드시 초기화해야한다.
- 멤버 변수의 초기화 방법
  - 1. 명시적 초기화(explicit initialization)
  - 2. 생성자(constructor)
  - 3. 초기화 블럭(initialization block)
    - 인스턴스 초기화 블럭 : 인스턴스변수를 초기화 하는데 사용
    - 클래스 초기화 블럭 : 클래스변수를 초기화 하는데 사용

### 6.2 명시적 초기화(explicit initialization)

- 변수를 선언과 동시에 초기화 하는 것

### 6.3 초기화 블럭(initialization block)

- 인스턴스 초기화 블럭 : 인스턴스변수를 초기화 하는데 사용
- 클래스 초기화 블럭 : 클래스변수를 초기화 하는데 사용

```java
class InitBlock{
  static { /* 클래스 초기화블럭 */}
  { /* 인스턴스 초기화블럭 */ }
}
```

- 클래스 초기화 블럭은 메모리에 처음 로딩될 때 한번만 수행
- 인스턴스 초기화 블럭은 생성자와 같이 인스턴스를 생성할 때 마다 수행
- 생성자보다 인스턴스 초기화 블럭이 먼저 수행된다.
- 코드의 중복을 제거 -> 코드의 신뢰성 증가, 오륙 발새 가능성 감소 -> 재상용성을 높이고 중복을 제거하는 것

### 6.4 멤버변수의 초기화 시기와 순서

- 클래스변수의 초기화 시점 : 클래스가 처음 로딩될 때 단 한번 초기화
- 인스턴스변수의 초기화 시점 : 인스턴스가 생설될 때마다 각 인스턴스별로 초기화
- 클래스변수의 초기화 순서 : 기본값 -> 명시적초기화 -> 클래스 초기화 블럭
- 인스턴스변수의 초기화 순서 : 기본값 ->명시적초기화 -> 인스턴스 초기화 블럭 -> 생성자
