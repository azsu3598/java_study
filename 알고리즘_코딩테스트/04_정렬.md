|  정렬 알고리즘  |                                          정의                                           |
| :-------------: | :-------------------------------------------------------------------------------------: |
|  버블(bubble)   |           데이터의 인접 요소끼리 비교하고, swap 연산을 수행하며 정렬하는 방식           |
|  선택(section)  |        대상에서 가장 크거나 작은 데이터를 찾아가 선택을 반복하면서 정렬하는 방식        |
| 삽입(insertion) | 대상을 선택해 정렬된 영역에서 선택 데이터의 적절한 위치를 찾아 삽입하면서 정렬하는 방식 |
|    퀵(quick)    |                   pivot 값을 선정해 해당 값을 기준으로 정렬하는 방식                    |
|   병합(merge)   |            이미 정렬된 부분 집합들을 효율적으로 병합해 전체를 정렬하는 방식             |
|   기수(radix)   |                데이터의 자릿수를 바탕으로 비교해 데이터를 정렬하는 방식                 |

### 버블 정렬

- 두 인접한 데이터의 크기를 비교해 정렬하는 방법
- 시간 복잡도 : O(n^2)

- 버블 정렬 과정
  - 1. 비교 연산이 필요한 루프 범위 설정
  - 2. 인접한 데이터 값 비교
  - 3. swap 조건에 부합하면 swap 연산 수행
  - 4. 루프 범위가 끝 날때까지 2~3 반복
  - 5. 정렬 영역 설정
  - 6. 비교 대상일 없을 때까지 1~5 반복

#### 문제 15 : 수 정렬하기 1 (백준 : 2750번 - 브론즈ⅰ)

#### 문제 16 : 버블 소트 프로그램 1

### 선택 정렬

- 대상 데이터에서 최대나 최소 데이터를 데이터가 나열된 순으로 찾아가며 선택하는 방법
- 시간 복잡도 : O(n^2)

- 핵심 이론 :
  - 최솟값 또는 최댓값을 찾고, 남은 정렬 부분의 가장 앞에 있는 데이터와 swap하는 것
  - 선택 정렬 과정
    - 1. 남은 정렬 부분에서 최솟값 또는 최댓값을 찾는다.
    - 2. 남은 정렬 부분에서 가장 앞에 있는 데이터와 선택된 데이터를 swap한다.
    - 3. 가장 앞에 있는 데이터의 위치를 변경해(index++) 남은 정렬 부분의 범위를 최소화한다.
    - 4. 전체 데이터 크기만큼 index가 커질 때까지, 즉 남은 정렬 부분이 없을 때까지 반복한다.

#### 문제 17 : 내림차순으로 자릿수 정렬하기(백준 : 1427번 - 실버ⅴ)

### 삽입 정렬

- 이미 정렬된 데이터 범위에 정렬되지 않은 데이터를 적절한 위치에 삽입시켜 정렬하는 방식
- 평균 시간 복잡도 : O(n^2)
  - 핵심 이론 :
    - 선택 데이터를 현재 정렬된 데이터 범위 내에서 적절한 위치에 삽입하는 것
  - 삽입 정렬 수행 방식
    - 1. 현재 index에 있는 데이터 값을 선택
    - 2. 현재 선택한 데이터가 정렬된 데이터 범위에 삽입될 위치를 탐색
    - 3. 삽입 위치부터 index에 있는 위치까지 shift 연산 수행
    - 4. 삽입 위치에 현재 선택한 데이터를 삽입하고 index++ 연산 수행
    - 5. 전체 데이터의 크기만큼 index가 커질 때까지, 즉 선택할 데이터가 없을 때까지 반복
  - 이직 탐색 등과 같은 탐색 알고리즘을 사용하면 시간 복잡도를 줄일 수 있다.

#### 문제 18 : ATM 인출 시간 계산하기 ( 백준 : 11399번 - 실버ⅲ)

### 퀵 정렬

- 기준값을 선정해 해당 값보다 작은 데이터와 큰 데이터로 분류하는 것을 반복해 정렬하는 알고리즘
- 평균 시간 복잡도 : O(nlogn)
- 기준값 -> pivot

  - 퀵 정렬 과정
    - 1. 데이터를 분할하는 pivot을 설정
    - 2. pivot을 기준으로 다음 a~e 과정을 거쳐 데이터를 2개의 집합으로 분리
      - a. start가 가리키는 데이터가 pivot이 카리키는 데이터보다 작으면 start를 오른쪽으로 1칸 이동
      - b. end가 가리키는 데이터가 pivot이 가리키는 데이터보다 크면 end를 왼쪽으로 1칸 이동
      - c. start가 가리키는 데이터가 pivot이 가리키는 데이터보다 크고, end가 가리키는 데이터가 pivot이 가리키는 데이터보다 작으면 start, end가 가리키는 데이터를 swap하고 start는 오른쪽, end는 왼쪽으로 1칸씩 이동
      - d. start와 end가 만날 때까지 a~c를 반복
      - e. start와 end가 만나면 만나 지점에서 가리키는 데이터와 pivot이 가리키는 데이터를 비교하여 pivot이 가리키는 데이터가 크면 만난 지점의 오른쪽에, 작으면 만나 지점의 왼쪽에 pivot이 가리키는 데이터를 삽입
    - 3. 분리 집합에서 각각다시 pivot을 선정
    - 4. 분리 집합이 1개 이하가 될 때까지 과정 1~3 반복
  - 재귀 함수

### 병합 정렬

- 분할정복방식을 사용해 데이터를 분할하고 분할한 집합을 정렬하며 합치는 알고리즘
- 평균 시간 복잡도 : O(nlogn)

  - 수행방식

#### 문제 20 : 수 정렬하기2(백준 : 2751번 - 실버ⅴ)

#### 문제 21 : 버블 소트 프로그램2(백준 : 1517번 - 플래티넘) \*

- 병합 정렬로 풀기
- 20번 문제에서 횟수를 더하는 로직만 추가

### 기수 정렬 \*

- 값을 비교하지 않는 특이한 정렬
- 값을 놓고 비교할 자릿수를 정한 다음 해당 자릿수만 비교
- 시간 복잡도 : O(kn) // k는 자릿수
- 큐를 사용
